name: ETH Anchor → GitHub JSON

on:
  schedule:
    - cron: "*/5 * * * *"        # wake every 5 min
  workflow_dispatch:
    inputs:
      force_commit:
        description: "Commit even if snapshot is considered stale"
        type: boolean
        default: false

permissions:
  contents: write

concurrency:
  group: eth-anchor
  cancel-in-progress: false

env:
  PRIMARY_URL: https://ethusd-anchor.vercel.app/api/eth-snapshot
  FALLBACK_RAW: https://raw.githubusercontent.com/mobilemid/ethusd-anchor/refs/heads/main/data/latest_eth_snapshot.json
  TZ: America/Chicago

jobs:
  anchor:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          persist-credentials: true
          fetch-depth: 0

      - name: Install jq
        run: sudo apt-get update && sudo apt-get install -y jq

      - name: Time gate (01/07/13/19:35 CT) with early-wait / late-grace
        id: gate
        shell: bash
        run: |
          set -euo pipefail
          NOW_CT=$(date +%s)
          TODAY=$(date +%Y-%m-%d)
          target=""
          for hh in 01 07 13 19; do
            t=$(date -d "$TODAY $hh:35:00" +%s)
            if [ $NOW_CT -le $t ]; then target=$t; break; fi
          done
          if [ -z "$target" ]; then
            TOM=$(date -d 'tomorrow' +%Y-%m-%d)
            target=$(date -d "$TOM 01:35:00" +%s)
          fi
          early=$(( target - NOW_CT ))
          if [ $early -gt 0 ] && [ $early -le 600 ]; then
            echo "Early by ${early}s — sleeping to hit the slot…"
            sleep $early
          fi
          LAG=$(( $(date +%s) - target ))
          echo "slot_epoch=$target" >> $GITHUB_OUTPUT
          echo "lag_sec=$LAG" >> $GITHUB_OUTPUT
          echo "now_ct=$(date --iso-8601=seconds)" >> $GITHUB_OUTPUT

      - name: Fetch anchor (PRIMARY Vercel, fallback GitHub) + validate + freshness
        id: fetch
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p data
          OUT=data/latest_eth_snapshot.json
          TMP=data/_tmp.json

          get_json () {
            url="$1"
            curl -sS -w '%{http_code}' \
              -H 'Cache-Control: no-cache' \
              --connect-timeout 10 --max-time 25 \
              -o "$TMP" "${url}?t=${GITHUB_RUN_ID}-${GITHUB_RUN_ATTEMPT}-$(date +%s)" || true
          }

          ok=0
          for i in 1 2 3 4 5 6; do
            code=$(get_json "$PRIMARY_URL")
            if [ "$code" = "200" ] && jq -e '.anchor.price|numbers' "$TMP" >/dev/null 2>&1; then ok=1; break; fi
            echo "Vercel try $i failed (HTTP=$code). Sleep $((i*2))s…"
            sleep $((i*2))
          done

          if [ "$ok" = "0" ]; then
            echo "PRIMARY failed; trying fallback RAW…"
            code=$(curl -sS -w '%{http_code}' -o "$TMP" "$FALLBACK_RAW" || true)
            if [ "$code" != "200" ] || ! jq -e '.anchor.price|numbers' "$TMP" >/dev/null 2>&1; then
              echo "status=fail" >> $GITHUB_OUTPUT
              echo "::error::Both sources failed (HTTP=$code)."
              exit 0
            fi
          fi

          slot=${{ steps.gate.outputs.slot_epoch }}
          fresh="false"; fresh_reason="n/a"

          ts_clock=$(jq -r '.clock.ts_ct // empty' "$TMP" || true)
          if [ -n "$ts_clock" ]; then
            t_epoch=$(date -d "$ts_clock" +%s || echo 0)
            if [ "$t_epoch" -ge "$slot" ]; then fresh="true"; else fresh_reason="clock.ts_ct < slot"; fi
          else
            lt=$(jq -r '.anchor.local_timestamp // empty' "$TMP" || true)
            if [ -n "$lt" ]; then
              t_epoch=$(date -d "$lt" +%s || echo 0)
              low=$(( slot - 600 )); high=$(( slot + 600 ))
              if [ "$t_epoch" -ge "$low" ] && [ "$t_epoch" -le "$high" ]; then fresh="true"; else fresh_reason="local_timestamp not within ±10m of slot"; fi
            else
              age=$(jq -r '.anchor.anchor_age_seconds // 999999' "$TMP")
              if [ "$age" != "null" ] && [ "$age" -le 1800 ]; then fresh="true"; else fresh_reason="age>1800s & no timestamps"; fi
            fi
          fi

          jq \
            --arg ts "${{ steps.gate.outputs.now_ct }}" \
            --argjson slot $slot \
            --argjson lag ${{ steps.gate.outputs.lag_sec }} \
            --arg fresh "$fresh" \
            --arg reason "$fresh_reason" \
            '.clock.ts_ct=$ts
             | .clock.anchor_target_epoch=$slot
             | .clock.anchor_lag_sec=$lag
             | .clock.fresh=$fresh
             | .clock.fresh_reason=$reason' "$TMP" | jq --sort-keys '.' > "$OUT"

          echo "status=ok" >> $GITHUB_OUTPUT
          echo "fresh=$fresh" >> $GITHUB_OUTPUT
          echo "fresh_reason=$fresh_reason" >> $GITHUB_OUTPUT
          echo "Snapshot fresh? $fresh ($fresh_reason)"

          # Always append a CSV row for observability
          if [ ! -f data/anchor_log.csv ]; then
            echo "ts_ct,anchor,used,age_sec,cross_price,disc_level,disc_diff_pct,anchor_lag_sec,fresh,fresh_reason" > data/anchor_log.csv
          fi
          jq -r --arg ts "${{ steps.gate.outputs.now_ct }}" \
                --arg lag "${{ steps.gate.outputs.lag_sec }}" \
                --arg fr "$fresh" --arg rr "$fresh_reason" '
            [
              $ts, .anchor.price, .anchor.used,
              (.anchor.anchor_age_seconds // ""),
              (.cross_check.price // ""),
              (.cross_check.discrepancy.level // ""),
              (.cross_check.discrepancy.diff_pct // ""),
              $lag, $fr, $rr
            ] | @csv' "$OUT" >> data/anchor_log.csv

      - name: Commit & push
        if: steps.fetch.outputs.status == 'ok' && (steps.fetch.outputs.fresh == 'true' || inputs.force_commit)
        shell: bash
        run: |
          set -euo pipefail
          git config user.name  "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git add data/latest_eth_snapshot.json data/anchor_log.csv
          if git diff --cached --quiet; then
            echo "No file changes to commit."
            exit 0
          fi
          git commit -m "snapshot: ${{ steps.gate.outputs.now_ct }} (fresh=${{ steps.fetch.outputs.fresh }} reason='${{ steps.fetch.outputs.fresh_reason }}')"
          git push
