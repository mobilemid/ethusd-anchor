name: ETH Anchor → GitHub JSON

on:
  schedule:
    - cron: "1 * * * *"       # every hour at :01 UTC
  workflow_dispatch:
    inputs:
      force_commit:
        description: "Commit even if snapshot is stale or unchanged"
        type: boolean
        default: false

permissions:
  contents: write

concurrency:
  group: eth-anchor
  cancel-in-progress: false

env:
  PRIMARY_URL: https://ethusd-anchor.vercel.app/api/eth-snapshot
  FALLBACK_RAW: https://raw.githubusercontent.com/mobilemid/ethusd-anchor/refs/heads/main/data/latest_eth_snapshot.json
  TZ: America/Chicago

jobs:
  anchor:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          persist-credentials: true
          fetch-depth: 0

      - name: Install jq
        run: sudo apt-get update && sudo apt-get install -y jq

      - name: Fetch anchor (PRIMARY Vercel → fallback RAW) and assess freshness
        id: fetch
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p data
          OUT='data/latest_eth_snapshot.json'
          TMP='data/_tmp.json'

          fetch_json () {
            local url="$1"
            curl -sS -H 'Cache-Control: no-cache' \
                 --connect-timeout 10 --max-time 20 \
                 -w '\n%{http_code}\n' \
                 "${url}?t=${GITHUB_RUN_ID}-${GITHUB_RUN_ATTEMPT}-$(date +%s)" > "$TMP.resp" || true
            tail -n1 "$TMP.resp" > "$TMP.code"
            sed '$d' "$TMP.resp" > "$TMP"
          }

          ok=0
          for i in 1 2 3 4 5; do
            fetch_json "$PRIMARY_URL"
            code=$(cat "$TMP.code")
            if [ "$code" = "200" ] && jq -e '.anchor.price|numbers' "$TMP" >/dev/null 2>&1; then ok=1; break; fi
            echo "Primary attempt $i failed (HTTP=$code). Sleeping $((i*2))s…"
            sleep $((i*2))
          done

          if [ "$ok" = "0" ]; then
            echo "Primary failed; trying fallback RAW…"
            curl -sS -H 'Cache-Control: no-cache' --connect-timeout 10 --max-time 20 \
                 -o "$TMP" "$FALLBACK_RAW" || true
            if ! jq -e '.anchor.price|numbers' "$TMP" >/dev/null 2>&1; then
              echo "status=fail" >> "$GITHUB_OUTPUT"
              echo "::error::Both sources failed."
              exit 0
            fi
          fi

          NOW_ISO=$(date --iso-8601=seconds)
          NOW_EPOCH=$(date +%s)

          fresh=false
          reason="n/a"

          ts_clock=$(jq -r '.clock.ts_ct // empty' "$TMP" || true)
          if [ -n "$ts_clock" ]; then
            te=$(date -d "$ts_clock" +%s || echo 0)
            age=$(( NOW_EPOCH - te ))
            if [ $age -le 900 ]; then fresh=true; else reason="clock.ts_ct age ${age}s > 900"; fi
          else
            lt=$(jq -r '.anchor.local_timestamp // empty' "$TMP" || true)
            if [ -n "$lt" ]; then
              te=$(date -d "$lt" +%s || echo 0)
              age=$(( NOW_EPOCH - te ))
              if [ $age -le 900 ]; then fresh=true; else reason="local_timestamp age ${age}s > 900"; fi
            else
              asec=$(jq -r '.anchor.anchor_age_seconds // empty' "$TMP" || true)
              if [ -n "${asec:-}" ] && [ "$asec" != "null" ] && [ "$asec" -le 1800 ]; then fresh=true; else reason="no timestamps & anchor_age_seconds > 1800"; fi
            fi
          fi

          jq \
            --arg now "$NOW_ISO" \
            --arg fresh "$fresh" \
            --arg reason "$reason" \
            --argjson now_epoch "$NOW_EPOCH" \
            '
            .clock.ts_ct = $now
            | .clock.checked_epoch = $now_epoch
            | .clock.fresh = ($fresh=="true")
            | .clock.fresh_reason = $reason
            ' "$TMP" | jq --sort-keys '.' > "$OUT"

          echo "status=ok" >> "$GITHUB_OUTPUT"
          echo "fresh=$fresh" >> "$GITHUB_OUTPUT"
          echo "fresh_reason=$reason" >> "$GITHUB_OUTPUT"
          echo "Anchor: $(jq -r '.anchor.price' "$OUT") | fresh=$fresh ($reason) at $NOW_ISO"

          if [ ! -f data/anchor_log.csv ]; then
            echo "ts_ct,anchor,used,age_sec,cross_price,disc_level,disc_diff_pct,fresh,fresh_reason" > data/anchor_log.csv
          fi
          jq -r --arg ts "$NOW_ISO" --arg fr "$fresh" --arg rr "$reason" '
            [ $ts,
              .anchor.price,
              .anchor.used,
              (.anchor.anchor_age_seconds // ""),
              (.cross_check.price // ""),
              (.cross_check.discrepancy.level // ""),
              (.cross_check.discrepancy.diff_pct // ""),
              ($fr=="true"),
              $rr
            ] | @csv' "$OUT" >> data/anchor_log.csv

      - name: Commit & push (always write snapshot; freshness is annotated)
        if: steps.fetch.outputs.status == 'ok' || inputs.force_commit
        shell: bash
        run: |
          set -euo pipefail
          git config user.name  "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git add data/latest_eth_snapshot.json data/anchor_log.csv
          if git diff --cached --quiet; then
            echo "No file changes to commit."
            exit 0
          fi
          msg="snapshot: $(date --iso-8601=seconds) (fresh=${{ steps.fetch.outputs.fresh || 'false' }} reason='${{ steps.fetch.outputs.fresh_reason || 'unknown' }}')"
          git commit -m "$msg"
          git push
